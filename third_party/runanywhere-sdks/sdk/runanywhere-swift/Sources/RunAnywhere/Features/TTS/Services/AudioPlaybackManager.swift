//
//  AudioPlaybackManager.swift
//  RunAnywhere SDK
//
//  Shared audio playback utility for TTS features.
//  Plays WAV audio data from TTS synthesis.
//

import AVFoundation
import Foundation

/// Manages audio playback for TTS services.
///
/// This is a shared utility that works with any TTS backend (ONNX/Piper, etc.).
/// It plays WAV audio data (16-bit PCM format) generated by TTS synthesis.
///
/// - Works on: iOS, tvOS, and macOS
///
/// ## Usage
/// ```swift
/// let playback = AudioPlaybackManager()
/// try await playback.play(audioData)
/// // or with completion callback
/// playback.play(audioData) { success in
///     print("Playback finished: \(success)")
/// }
/// ```
public class AudioPlaybackManager: NSObject, ObservableObject, AVAudioPlayerDelegate {
    private let logger = SDKLogger(category: "AudioPlayback")

    private var audioPlayer: AVAudioPlayer?
    private var playbackCompletion: ((Bool) -> Void)?
    private var playbackContinuation: CheckedContinuation<Void, Error>?

    @Published public var isPlaying = false
    @Published public var currentTime: TimeInterval = 0.0
    @Published public var duration: TimeInterval = 0.0

    public override init() {
        super.init()
        logger.info("AudioPlaybackManager initialized")
    }

    // MARK: - Public API

    /// Play audio data asynchronously (async/await)
    /// - Parameter audioData: WAV audio data to play
    /// - Throws: AudioPlaybackError if playback fails
    public func play(_ audioData: Data) async throws {
        guard !audioData.isEmpty else {
            throw AudioPlaybackError.emptyAudioData
        }

        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            self.playbackContinuation = continuation

            do {
                try startPlayback(audioData)
            } catch {
                self.playbackContinuation = nil
                continuation.resume(throwing: error)
            }
        }
    }

    /// Play audio data with completion callback
    /// - Parameters:
    ///   - audioData: WAV audio data to play
    ///   - completion: Called when playback finishes (true = success, false = error/interrupted)
    public func play(_ audioData: Data, completion: @escaping (Bool) -> Void) {
        guard !audioData.isEmpty else {
            logger.warning("Empty audio data, skipping playback")
            completion(false)
            return
        }

        playbackCompletion = completion

        do {
            try startPlayback(audioData)
        } catch {
            logger.error("Failed to start playback: \(error)")
            playbackCompletion = nil
            completion(false)
        }
    }

    /// Stop current playback
    public func stop() {
        guard isPlaying else { return }

        audioPlayer?.stop()
        cleanupPlayback(success: false)
        logger.info("Playback stopped by user")
    }

    /// Pause current playback
    public func pause() {
        guard isPlaying else { return }
        audioPlayer?.pause()
        logger.info("Playback paused")
    }

    /// Resume paused playback
    public func resume() {
        guard let player = audioPlayer, !player.isPlaying else { return }
        player.play()
        logger.info("Playback resumed")
    }

    // MARK: - Private Implementation

    private func startPlayback(_ audioData: Data) throws {
        // Stop any existing playback
        if isPlaying {
            stop()
        }

        // Configure audio session for playback
        try configureAudioSession()

        // Create and configure audio player
        audioPlayer = try AVAudioPlayer(data: audioData)
        audioPlayer?.delegate = self
        audioPlayer?.prepareToPlay()

        duration = audioPlayer?.duration ?? 0.0
        currentTime = 0.0

        guard audioPlayer?.play() == true else {
            throw AudioPlaybackError.playbackFailed
        }

        DispatchQueue.main.async {
            self.isPlaying = true
        }

        logger.info("Playback started: \(audioData.count) bytes, duration: \(self.duration)s")

        // Start progress timer
        startProgressTimer()
    }

    private func configureAudioSession() throws {
        #if os(iOS) || os(tvOS)
        let audioSession = AVAudioSession.sharedInstance()
        try audioSession.setCategory(.playback, mode: .default, options: [.duckOthers])
        try audioSession.setActive(true)
        #endif
        // macOS doesn't require audio session configuration
    }

    private func deactivateAudioSession() {
        #if os(iOS) || os(tvOS)
        try? AVAudioSession.sharedInstance().setActive(false, options: .notifyOthersOnDeactivation)
        #endif
    }

    private var progressTimer: Timer?

    private func startProgressTimer() {
        progressTimer?.invalidate()
        progressTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { [weak self] _ in
            guard let self = self, let player = self.audioPlayer else { return }
            DispatchQueue.main.async {
                self.currentTime = player.currentTime
            }
        }
    }

    private func stopProgressTimer() {
        progressTimer?.invalidate()
        progressTimer = nil
    }

    private func cleanupPlayback(success: Bool) {
        stopProgressTimer()
        deactivateAudioSession()

        DispatchQueue.main.async {
            self.isPlaying = false
            self.currentTime = 0.0
        }

        // Complete async continuation if present
        if let continuation = playbackContinuation {
            playbackContinuation = nil
            if success {
                continuation.resume()
            } else {
                continuation.resume(throwing: AudioPlaybackError.playbackInterrupted)
            }
        }

        // Call completion handler if present
        if let completion = playbackCompletion {
            playbackCompletion = nil
            completion(success)
        }

        audioPlayer = nil
    }

    // MARK: - AVAudioPlayerDelegate

    public func audioPlayerDidFinishPlaying(_ player: AVAudioPlayer, successfully flag: Bool) {
        logger.info("Playback finished: \(flag ? "success" : "failed")")
        cleanupPlayback(success: flag)
    }

    public func audioPlayerDecodeErrorDidOccur(_ player: AVAudioPlayer, error: Error?) {
        logger.error("Playback decode error: \(error?.localizedDescription ?? "unknown")")
        cleanupPlayback(success: false)
    }

    #if os(iOS) || os(tvOS)
    public func audioPlayerBeginInterruption(_ player: AVAudioPlayer) {
        logger.info("Playback interrupted")
        DispatchQueue.main.async {
            self.isPlaying = false
        }
    }

    public func audioPlayerEndInterruption(_ player: AVAudioPlayer, withOptions flags: Int) {
        logger.info("Playback interruption ended")
        if flags == AVAudioSession.InterruptionOptions.shouldResume.rawValue {
            player.play()
            DispatchQueue.main.async {
                self.isPlaying = true
            }
        }
    }
    #endif

    deinit {
        stop()
    }
}

// MARK: - Errors

public enum AudioPlaybackError: LocalizedError {
    case emptyAudioData
    case playbackFailed
    case playbackInterrupted
    case invalidAudioFormat

    public var errorDescription: String? {
        switch self {
        case .emptyAudioData:
            return "Audio data is empty"
        case .playbackFailed:
            return "Failed to start audio playback"
        case .playbackInterrupted:
            return "Audio playback was interrupted"
        case .invalidAudioFormat:
            return "Invalid audio format"
        }
    }
}
