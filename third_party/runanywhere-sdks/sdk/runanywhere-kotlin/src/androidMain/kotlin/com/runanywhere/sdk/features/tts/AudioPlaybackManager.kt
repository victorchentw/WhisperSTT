package com.runanywhere.sdk.features.tts

import android.media.AudioAttributes
import android.media.AudioFormat
import android.media.AudioTrack
import com.runanywhere.sdk.foundation.SDKLogger
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.coroutines.withContext
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

/**
 * Manages audio playback for TTS services on Android.
 * Plays WAV audio data (16-bit PCM format) generated by TTS synthesis.
 *
 * Matches iOS AudioPlaybackManager behavior.
 */
class AudioPlaybackManager {
    private val logger = SDKLogger.tts

    private var audioTrack: AudioTrack? = null

    @Volatile
    var isPlaying: Boolean = false
        private set

    /**
     * Play WAV audio data asynchronously.
     *
     * @param audioData WAV audio data to play (including WAV header)
     * @throws AudioPlaybackException if playback fails
     */
    suspend fun play(audioData: ByteArray) {
        if (audioData.isEmpty()) {
            throw AudioPlaybackException.EmptyAudioData
        }

        withContext(Dispatchers.IO) {
            try {
                // Parse WAV header to get audio parameters
                val wavInfo = parseWavHeader(audioData)
                logger.info("Playing audio: ${audioData.size} bytes, ${wavInfo.sampleRate}Hz, ${wavInfo.channels}ch")

                // Get PCM data (skip WAV header)
                val pcmData = audioData.copyOfRange(wavInfo.dataOffset, audioData.size)

                playPcmData(pcmData, wavInfo.sampleRate, wavInfo.channels, wavInfo.bitsPerSample)

                logger.info("Playback completed")
            } catch (e: Exception) {
                logger.error("Playback failed: ${e.message}")
                throw if (e is AudioPlaybackException) e else AudioPlaybackException.PlaybackFailed(e.message)
            }
        }
    }

    /**
     * Stop current playback.
     */
    fun stop() {
        if (!isPlaying) return

        try {
            audioTrack?.stop()
            audioTrack?.release()
            audioTrack = null
        } catch (e: Exception) {
            logger.error("Error stopping playback: ${e.message}")
        }

        isPlaying = false
        logger.info("Playback stopped")
    }

    private suspend fun playPcmData(
        pcmData: ByteArray,
        sampleRate: Int,
        channels: Int,
        bitsPerSample: Int,
    ) = suspendCancellableCoroutine { continuation ->
        try {
            val channelConfig =
                if (channels == 1) {
                    AudioFormat.CHANNEL_OUT_MONO
                } else {
                    AudioFormat.CHANNEL_OUT_STEREO
                }

            val audioFormat =
                if (bitsPerSample == 16) {
                    AudioFormat.ENCODING_PCM_16BIT
                } else {
                    AudioFormat.ENCODING_PCM_8BIT
                }

            val minBufferSize =
                AudioTrack.getMinBufferSize(
                    sampleRate,
                    channelConfig,
                    audioFormat,
                )

            if (minBufferSize == AudioTrack.ERROR || minBufferSize == AudioTrack.ERROR_BAD_VALUE) {
                continuation.resumeWithException(AudioPlaybackException.InvalidAudioFormat)
                return@suspendCancellableCoroutine
            }

            val bufferSize = maxOf(minBufferSize, pcmData.size)

            val track =
                AudioTrack
                    .Builder()
                    .setAudioAttributes(
                        AudioAttributes
                            .Builder()
                            .setUsage(AudioAttributes.USAGE_MEDIA)
                            .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                            .build(),
                    ).setAudioFormat(
                        AudioFormat
                            .Builder()
                            .setEncoding(audioFormat)
                            .setSampleRate(sampleRate)
                            .setChannelMask(channelConfig)
                            .build(),
                    ).setBufferSizeInBytes(bufferSize)
                    .setTransferMode(AudioTrack.MODE_STATIC)
                    .build()

            audioTrack = track
            isPlaying = true

            // Write all data
            val bytesWritten = track.write(pcmData, 0, pcmData.size)
            if (bytesWritten < 0) {
                track.release()
                audioTrack = null
                isPlaying = false
                continuation.resumeWithException(AudioPlaybackException.PlaybackFailed("Write failed: $bytesWritten"))
                return@suspendCancellableCoroutine
            }

            // Set notification marker at end
            track.notificationMarkerPosition = pcmData.size / (bitsPerSample / 8 * channels)
            track.setPlaybackPositionUpdateListener(
                object : AudioTrack.OnPlaybackPositionUpdateListener {
                    override fun onMarkerReached(track: AudioTrack?) {
                        isPlaying = false
                        track?.stop()
                        track?.release()
                        audioTrack = null
                        continuation.resume(Unit)
                    }

                    override fun onPeriodicNotification(track: AudioTrack?) {
                        // Not used
                    }
                },
            )

            // Handle cancellation
            continuation.invokeOnCancellation {
                stop()
            }

            // Start playback
            track.play()
        } catch (e: Exception) {
            isPlaying = false
            audioTrack?.release()
            audioTrack = null
            continuation.resumeWithException(e)
        }
    }

    private fun parseWavHeader(data: ByteArray): WavInfo {
        if (data.size < 44) {
            throw AudioPlaybackException.InvalidAudioFormat
        }

        // Check RIFF header
        val riff = String(data.copyOfRange(0, 4))
        if (riff != "RIFF") {
            throw AudioPlaybackException.InvalidAudioFormat
        }

        // Check WAVE format
        val wave = String(data.copyOfRange(8, 12))
        if (wave != "WAVE") {
            throw AudioPlaybackException.InvalidAudioFormat
        }

        // Parse fmt chunk
        val channels = (data[22].toInt() and 0xFF) or ((data[23].toInt() and 0xFF) shl 8)
        val sampleRate =
            (data[24].toInt() and 0xFF) or
                ((data[25].toInt() and 0xFF) shl 8) or
                ((data[26].toInt() and 0xFF) shl 16) or
                ((data[27].toInt() and 0xFF) shl 24)
        val bitsPerSample = (data[34].toInt() and 0xFF) or ((data[35].toInt() and 0xFF) shl 8)

        // Find data chunk (usually at offset 44 but can vary)
        var dataOffset = 12
        while (dataOffset < data.size - 8) {
            val chunkId = String(data.copyOfRange(dataOffset, dataOffset + 4))
            val chunkSize =
                (data[dataOffset + 4].toInt() and 0xFF) or
                    ((data[dataOffset + 5].toInt() and 0xFF) shl 8) or
                    ((data[dataOffset + 6].toInt() and 0xFF) shl 16) or
                    ((data[dataOffset + 7].toInt() and 0xFF) shl 24)

            if (chunkId == "data") {
                dataOffset += 8 // Skip chunk header
                break
            }

            dataOffset += 8 + chunkSize
        }

        return WavInfo(
            sampleRate = sampleRate,
            channels = channels,
            bitsPerSample = bitsPerSample,
            dataOffset = dataOffset,
        )
    }

    private data class WavInfo(
        val sampleRate: Int,
        val channels: Int,
        val bitsPerSample: Int,
        val dataOffset: Int,
    )
}

/**
 * Audio playback errors.
 */
sealed class AudioPlaybackException : Exception() {
    data object EmptyAudioData : AudioPlaybackException() {
        @Suppress("UnusedPrivateMember")
        private fun readResolve(): Any = EmptyAudioData

        override val message: String = "Audio data is empty"
    }

    data class PlaybackFailed(
        override val message: String?,
    ) : AudioPlaybackException()

    data object PlaybackInterrupted : AudioPlaybackException() {
        @Suppress("UnusedPrivateMember")
        private fun readResolve(): Any = PlaybackInterrupted

        override val message: String = "Audio playback was interrupted"
    }

    data object InvalidAudioFormat : AudioPlaybackException() {
        @Suppress("UnusedPrivateMember")
        private fun readResolve(): Any = InvalidAudioFormat

        override val message: String = "Invalid audio format"
    }
}
